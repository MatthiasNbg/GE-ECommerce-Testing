"""
Session Security Penetration Tests

Tests für:
- Session Hijacking
- Session Fixation
- Insecure Cookie Attributes
- CSRF Protection
- Session Timeout

⚠️ WARNING: Diese Tests dürfen NUR auf autorisierten Systemen ausgeführt werden!
"""

import pytest
from playwright.async_api import Page, BrowserContext
from typing import Dict, List


@pytest.mark.pentest
@pytest.mark.session
async def test_secure_cookie_attributes(page: Page, context: BrowserContext, base_url: str):
    """
    Testet, ob Session-Cookies sichere Attribute haben.

    Erwartung: Session-Cookies sollten haben:
    - HttpOnly: true (verhindert JavaScript-Zugriff)
    - Secure: true (nur HTTPS)
    - SameSite: Lax oder Strict (CSRF-Schutz)

    OWASP: A05:2021 - Security Misconfiguration
    """
    await page.goto(base_url)

    cookies = await context.cookies()

    session_cookies = []

    # Finde Session-Cookies
    for cookie in cookies:
        cookie_name_lower = cookie["name"].lower()

        if any(
            keyword in cookie_name_lower
            for keyword in ["session", "phpsessid", "jsessionid", "asp.net", "auth"]
        ):
            session_cookies.append(cookie)

    if len(session_cookies) == 0:
        pytest.skip("No session cookies found")

    security_issues = []

    for cookie in session_cookies:
        cookie_name = cookie["name"]

        # Prüfe HttpOnly
        if not cookie.get("httpOnly", False):
            security_issues.append(f"{cookie_name}: Missing HttpOnly flag")

        # Prüfe Secure (nur bei HTTPS)
        if base_url.startswith("https://"):
            if not cookie.get("secure", False):
                security_issues.append(f"{cookie_name}: Missing Secure flag")

        # Prüfe SameSite
        same_site = cookie.get("sameSite", "None")

        if same_site.lower() == "none":
            security_issues.append(f"{cookie_name}: SameSite=None (CSRF risk)")

    # ERFOLGS-KRITERIUM: Alle Session-Cookies sollten sicher sein
    assert len(security_issues) == 0, (
        f"Insecure cookie attributes detected! "
        f"Issues:\n" + "\n".join([f"  - {issue}" for issue in security_issues])
    )


@pytest.mark.pentest
@pytest.mark.session
async def test_session_id_complexity(page: Page, context: BrowserContext, base_url: str):
    """
    Testet, ob Session-IDs ausreichend komplex/zufällig sind.

    Erwartung: Session-IDs sollten:
    - Mindestens 128 Bit Entropie haben
    - Nicht vorhersagbar sein
    - Kryptographisch sicher generiert sein

    OWASP: A02:2021 - Cryptographic Failures
    """
    await page.goto(base_url)

    cookies = await context.cookies()

    session_cookie = None

    for cookie in cookies:
        if "session" in cookie["name"].lower():
            session_cookie = cookie
            break

    if not session_cookie:
        pytest.skip("No session cookie found")

    session_id = session_cookie["value"]

    # Prüfe Länge
    min_length = 32  # 128 Bit = 32 Hex-Zeichen

    if len(session_id) < min_length:
        pytest.fail(
            f"Session ID too short! "
            f"Length: {len(session_id)}, Expected: >= {min_length}"
        )

    # Prüfe, ob Session-ID zu einfach ist (z.B. nur Zahlen)
    if session_id.isdigit():
        pytest.fail("Session ID contains only digits - possibly sequential!")

    # Prüfe auf verdächtige Muster
    if "0000" in session_id or "1111" in session_id or "aaaa" in session_id:
        pytest.fail(f"Session ID contains suspicious pattern: {session_id}")

    print(f"✓ Session ID appears complex: Length={len(session_id)}")


@pytest.mark.pentest
@pytest.mark.session
async def test_csrf_token_in_forms(page: Page, base_url: str):
    """
    Testet, ob Formulare CSRF-Tokens enthalten.

    Erwartung: Alle State-Changing-Formulare sollten CSRF-Tokens haben
    OWASP: A01:2021 - Broken Access Control (CSRF)

    Formulare, die getestet werden:
    - Login
    - Checkout
    - Profile-Edit
    - Address-Edit
    """
    forms_to_test = [
        {"url": "/account/login", "form": "form[method='post']"},
        {"url": "/checkout", "form": "form#checkout-form"},
        {"url": "/account/profile", "form": "form[method='post']"},
    ]

    missing_csrf = []

    for form_config in forms_to_test:
        try:
            await page.goto(f"{base_url}{form_config['url']}")
            await page.wait_for_load_state("networkidle", timeout=5000)

            # Finde Formular
            form = page.locator(form_config["form"]).first

            if not await form.count():
                continue  # Formular existiert nicht auf dieser Seite

            # Prüfe auf CSRF-Token
            form_html = await form.inner_html()

            has_csrf_token = (
                'name="_csrf_token"' in form_html
                or 'name="csrf"' in form_html
                or 'name="csrf_token"' in form_html
                or 'name="_token"' in form_html
                or 'name="authenticity_token"' in form_html  # Rails
            )

            if not has_csrf_token:
                missing_csrf.append(form_config["url"])

        except Exception:
            # Seite nicht erreichbar → überspringen
            pass

    # ERFOLGS-KRITERIUM: Alle Formulare sollten CSRF-Schutz haben
    if len(missing_csrf) > 0:
        print(
            f"Warning: Forms without CSRF tokens: {', '.join(missing_csrf)}. "
            f"Verify if CSRF protection is implemented via headers or other mechanism."
        )


@pytest.mark.pentest
@pytest.mark.session
async def test_session_hijacking_via_url(page: Page, base_url: str):
    """
    Testet, ob Session-IDs in URLs übertragen werden.

    Erwartung: Session-IDs sollten NICHT in URLs erscheinen
    OWASP: A05:2021 - Security Misconfiguration

    Beispiel unsicherer URLs:
    - /page?sessionid=abc123
    - /page;jsessionid=xyz789
    """
    await page.goto(base_url)

    # Navigiere durch verschiedene Seiten
    links = await page.locator("a").all()

    session_in_url = []

    for link in links[:20]:  # Nur erste 20 Links testen
        href = await link.get_attribute("href")

        if not href:
            continue

        href_lower = href.lower()

        # Prüfe auf Session-ID in URL
        if any(
            keyword in href_lower
            for keyword in ["sessionid=", "jsessionid=", "phpsessid=", "session="]
        ):
            session_in_url.append(href)

    # ERFOLGS-KRITERIUM: Keine Session-IDs in URLs
    assert len(session_in_url) == 0, (
        f"Session IDs found in URLs (Session Hijacking risk)! "
        f"URLs: {', '.join(session_in_url)}"
    )


@pytest.mark.pentest
@pytest.mark.session
async def test_session_timeout(page: Page, context: BrowserContext, base_url: str):
    """
    Testet, ob inaktive Sessions timeout haben.

    Erwartung: Nach Inaktivität sollte Session ablaufen
    OWASP: A07:2021 - Identification and Authentication Failures

    Hinweis: Dieser Test dauert lange (wartet auf Timeout).
    In Praxis: Timeout sollte 15-30 Minuten sein.
    Für Tests: Prüfen wir nur, ob Cookie Expires-Attribut gesetzt ist.
    """
    await page.goto(base_url)

    cookies = await context.cookies()

    session_cookie = None

    for cookie in cookies:
        if "session" in cookie["name"].lower():
            session_cookie = cookie
            break

    if not session_cookie:
        pytest.skip("No session cookie found")

    # Prüfe, ob Cookie Expires-Attribut hat
    expires = session_cookie.get("expires", -1)

    # Wenn expires == -1 → Session Cookie (wird bei Browser-Schließung gelöscht)
    # Das ist OK für Sessions

    # Wenn expires weit in der Zukunft (> 7 Tage) → Problematisch für Sessions
    if expires > 0:
        import time

        current_time = time.time()
        expires_in_seconds = expires - current_time
        expires_in_days = expires_in_seconds / 86400

        if expires_in_days > 7:
            print(
                f"Warning: Session cookie expires in {expires_in_days:.1f} days. "
                f"Consider shorter session lifetime."
            )


@pytest.mark.pentest
@pytest.mark.session
async def test_logout_invalidates_session(
    page: Page, context: BrowserContext, base_url: str
):
    """
    Testet, ob Logout Sessions tatsächlich invalidiert.

    Erwartung: Nach Logout sollte Session-Cookie gelöscht/ungültig sein
    OWASP: A07:2021 - Identification and Authentication Failures

    Test-Ablauf:
    1. Session-Cookie vor Logout speichern
    2. Logout durchführen
    3. Prüfen, ob Cookie gelöscht wurde
    4. Cookie manuell wieder setzen
    5. Versuch, geschützte Seite aufzurufen
    6. Erwartung: Redirect zu Login
    """
    pytest.skip("Test requires login credentials - implementation template")

    # Template-Implementation:
    # 1. Login durchführen
    # 2. Session-Cookie speichern
    # 3. Logout
    # 4. Prüfen, ob Cookie gelöscht wurde
    # 5. Cookie wieder setzen (via context.add_cookies())
    # 6. Geschützte Seite aufrufen
    # 7. Erwartung: Redirect zu Login


@pytest.mark.pentest
@pytest.mark.session
async def test_concurrent_session_limit(browser, base_url: str):
    """
    Testet, ob gleichzeitige Sessions limitiert sind.

    Erwartung: Nur N gleichzeitige Sessions pro User erlaubt
    OWASP: A07:2021 - Identification and Authentication Failures

    Test-Ablauf:
    1. Login in 5 verschiedenen Browser-Contexts
    2. Prüfen, ob alle 5 Sessions aktiv sind
    3. Erwartung: Alte Sessions sollten invalidiert werden
    """
    pytest.skip("Test requires login credentials - implementation template")


@pytest.mark.pentest
@pytest.mark.session
async def test_session_regeneration_after_login(
    page: Page, context: BrowserContext, base_url: str
):
    """
    Testet, ob Session-ID nach Login erneuert wird.

    Erwartung: Session-ID sollte sich nach Login ändern (Session Fixation-Schutz)
    OWASP: A07:2021 - Identification and Authentication Failures
    """
    pytest.skip("Test requires login credentials - implementation template")

    # Template-Implementation:
    # 1. await page.goto(base_url)
    # 2. cookies_before = await context.cookies()
    # 3. session_id_before = [c for c in cookies_before if 'session' in c['name'].lower()]
    # 4. Login durchführen
    # 5. cookies_after = await context.cookies()
    # 6. session_id_after = [c for c in cookies_after if 'session' in c['name'].lower()]
    # 7. assert session_id_before != session_id_after


@pytest.mark.pentest
@pytest.mark.session
async def test_clickjacking_protection(page: Page, base_url: str):
    """
    Testet Clickjacking-Schutz via X-Frame-Options oder CSP.

    Erwartung: Seiten sollten X-Frame-Options oder CSP frame-ancestors haben
    OWASP: A05:2021 - Security Misconfiguration

    Schutz-Optionen:
    - X-Frame-Options: DENY oder SAMEORIGIN
    - Content-Security-Policy: frame-ancestors 'self'
    """
    response = await page.goto(base_url)

    if not response:
        pytest.skip("No response received")

    headers = response.headers

    # Prüfe X-Frame-Options
    x_frame_options = headers.get("x-frame-options", "").lower()

    # Prüfe CSP
    csp = headers.get("content-security-policy", "").lower()

    has_protection = False

    if x_frame_options in ["deny", "sameorigin"]:
        has_protection = True

    if "frame-ancestors" in csp:
        has_protection = True

    # ERFOLGS-KRITERIUM: Clickjacking-Schutz sollte vorhanden sein
    assert has_protection, (
        "No Clickjacking protection detected! "
        "Missing X-Frame-Options or CSP frame-ancestors header."
    )


@pytest.mark.pentest
@pytest.mark.session
async def test_security_headers(page: Page, base_url: str):
    """
    Testet wichtige Security-Header.

    Erwartung: Folgende Header sollten gesetzt sein:
    - X-Content-Type-Options: nosniff
    - X-XSS-Protection: 1; mode=block (veraltet, aber noch verbreitet)
    - Strict-Transport-Security (HSTS) bei HTTPS
    - Content-Security-Policy (CSP)

    OWASP: A05:2021 - Security Misconfiguration
    """
    response = await page.goto(base_url)

    if not response:
        pytest.skip("No response received")

    headers = response.headers

    missing_headers = []

    # X-Content-Type-Options
    if "x-content-type-options" not in headers:
        missing_headers.append("X-Content-Type-Options: nosniff")

    # HSTS (nur bei HTTPS)
    if base_url.startswith("https://"):
        if "strict-transport-security" not in headers:
            missing_headers.append("Strict-Transport-Security (HSTS)")

    # CSP
    if "content-security-policy" not in headers:
        missing_headers.append("Content-Security-Policy")

    # Referrer-Policy
    if "referrer-policy" not in headers:
        missing_headers.append("Referrer-Policy")

    # Permissions-Policy (früher Feature-Policy)
    if "permissions-policy" not in headers and "feature-policy" not in headers:
        missing_headers.append("Permissions-Policy")

    # WARNUNG bei fehlenden Headern (nicht unbedingt kritisch)
    if len(missing_headers) > 0:
        print(
            f"Warning: Missing security headers:\n"
            + "\n".join([f"  - {h}" for h in missing_headers])
        )


@pytest.mark.pentest
@pytest.mark.session
async def test_https_only(page: Page, base_url: str):
    """
    Testet, ob alle Requests über HTTPS laufen.

    Erwartung: Keine HTTP-Requests für sensible Daten
    OWASP: A02:2021 - Cryptographic Failures
    """
    if not base_url.startswith("https://"):
        pytest.skip("Base URL is not HTTPS - skipping HTTPS-only test")

    insecure_requests = []

    # Request-Listener
    def on_request(request):
        if request.url.startswith("http://"):
            # Ausnahme: Lokale Ressourcen (z.B. localhost)
            if "localhost" not in request.url and "127.0.0.1" not in request.url:
                insecure_requests.append(request.url)

    page.on("request", on_request)

    # Navigiere durch Seite
    await page.goto(base_url)
    await page.wait_for_load_state("networkidle")

    # ERFOLGS-KRITERIUM: Keine HTTP-Requests
    assert len(insecure_requests) == 0, (
        f"Insecure HTTP requests detected! "
        f"URLs: {', '.join(insecure_requests[:5])}"  # Nur erste 5 zeigen
    )
