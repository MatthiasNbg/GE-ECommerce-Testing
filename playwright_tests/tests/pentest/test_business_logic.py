"""
E-Commerce Business Logic Penetration Tests

Tests für:
- Price Manipulation
- Inventory Bypass
- Coupon/Promo Code Abuse
- Payment Bypass
- Negative Quantity
- Race Conditions
- Order Manipulation

⚠️ WARNING: Diese Tests dürfen NUR auf autorisierten Systemen ausgeführt werden!
"""

import pytest
import asyncio
from playwright.async_api import Page, BrowserContext, Browser
from typing import List

from playwright_tests.utils.pentest_payloads import (
    PRICE_MANIPULATION_PAYLOADS,
    QUANTITY_MANIPULATION_PAYLOADS,
    COMMON_COUPON_CODES,
)


@pytest.mark.pentest
@pytest.mark.business_logic
async def test_price_manipulation_frontend(page: Page, base_url: str):
    """
    Testet Price Manipulation via Frontend (DevTools/JavaScript).

    Angriffsziel: Warenkorb, Checkout
    Erwartung: Server validiert Preise, ignoriert Client-seitige Änderungen
    OWASP: Business Logic Vulnerability

    Test-Ablauf:
    1. Produkt zum Warenkorb hinzufügen (Original-Preis merken)
    2. Via JavaScript Preis im DOM ändern
    3. Checkout durchführen
    4. Erwartung: Server verwendet Original-Preis, nicht manipulierten Preis
    """
    # Navigiere zu Produktseite
    await page.goto(f"{base_url}")

    # Finde ein Produkt
    product_link = page.locator("a.product-link, .product-item a, .product-box a").first

    if not await product_link.count():
        pytest.skip("No product found on homepage")

    await product_link.click()
    await page.wait_for_load_state("networkidle")

    # Original-Preis extrahieren
    price_element = page.locator(".product-price, .price, [data-price]").first

    if not await price_element.count():
        pytest.skip("Product price element not found")

    original_price_text = await price_element.text_content()

    # Extrahiere numerischen Preis (z.B. "99,99 €" → 99.99)
    import re

    price_match = re.search(r"(\d+[,.]?\d*)", original_price_text.replace(".", "").replace(",", "."))

    if not price_match:
        pytest.skip("Could not extract price from product page")

    original_price = float(price_match.group(1))

    # Produkt zum Warenkorb hinzufügen
    add_to_cart_btn = page.locator(
        "button:has-text('In den Warenkorb'), button.add-to-cart, .btn-buy"
    ).first

    if not await add_to_cart_btn.count():
        pytest.skip("Add to cart button not found")

    await add_to_cart_btn.click()
    await page.wait_for_timeout(2000)

    # JavaScript: Preis im DOM manipulieren
    manipulated_price = "0.01"

    await page.evaluate(
        f"""
        () => {{
            // Alle Preis-Elemente finden und ändern
            document.querySelectorAll('.price, .product-price, [data-price]').forEach(el => {{
                el.textContent = '{manipulated_price} €';
                if (el.hasAttribute('data-price')) {{
                    el.setAttribute('data-price', '{manipulated_price}');
                }}
            }});

            // Versteckte Input-Felder (falls vorhanden)
            document.querySelectorAll('input[name*="price"]').forEach(input => {{
                input.value = '{manipulated_price}';
            }});
        }}
    """
    )

    # Zum Warenkorb/Checkout navigieren
    await page.goto(f"{base_url}/checkout/cart")
    await page.wait_for_load_state("networkidle")

    # Preis im Warenkorb auslesen
    cart_price_element = page.locator(
        ".cart-item-price, .line-item-total-price, .total-price"
    ).first

    if await cart_price_element.count():
        cart_price_text = await cart_price_element.text_content()
        cart_price_match = re.search(
            r"(\d+[,.]?\d*)", cart_price_text.replace(".", "").replace(",", ".")
        )

        if cart_price_match:
            cart_price = float(cart_price_match.group(1))

            # ERFOLGS-KRITERIUM: Warenkorb sollte Original-Preis zeigen
            assert cart_price >= original_price * 0.9, (
                f"Price manipulation vulnerability! "
                f"Original: {original_price:.2f}, Cart: {cart_price:.2f}. "
                f"Server accepted manipulated price!"
            )

            print(f"✓ Price manipulation blocked. Original: {original_price:.2f}, Cart: {cart_price:.2f}")


@pytest.mark.pentest
@pytest.mark.business_logic
async def test_negative_quantity_injection(page: Page, base_url: str):
    """
    Testet Negative Quantity Injection im Warenkorb.

    Angriffsziel: Warenkorb-Mengenfelder
    Erwartung: Negative Mengen sollten abgelehnt werden
    OWASP: Business Logic Vulnerability

    Test-Ablauf:
    1. Produkt zum Warenkorb hinzufügen
    2. Menge auf negative Werte setzen (via DevTools)
    3. Erwartung: Server lehnt ab oder setzt auf 0/1
    """
    await page.goto(f"{base_url}")

    # Produkt finden und zum Warenkorb hinzufügen
    product_link = page.locator("a.product-link, .product-item a").first

    if not await product_link.count():
        pytest.skip("No product found")

    await product_link.click()
    await page.wait_for_load_state("networkidle")

    add_to_cart_btn = page.locator(
        "button:has-text('In den Warenkorb'), button.add-to-cart"
    ).first

    if await add_to_cart_btn.count():
        await add_to_cart_btn.click()
        await page.wait_for_timeout(2000)

    # Zum Warenkorb
    await page.goto(f"{base_url}/checkout/cart")
    await page.wait_for_load_state("networkidle")

    # Mengen-Feld finden
    quantity_input = page.locator("input[name*='quantity'], input.quantity-input").first

    if not await quantity_input.count():
        pytest.skip("Quantity input not found in cart")

    # Negative Werte testen
    negative_values = ["-1", "-999", "-100"]

    for negative_qty in negative_values:
        # Via JavaScript: Min-Validierung umgehen
        await page.evaluate(
            f"""
            () => {{
                const qtyInput = document.querySelector('input[name*="quantity"], input.quantity-input');
                if (qtyInput) {{
                    qtyInput.removeAttribute('min');
                    qtyInput.value = '{negative_qty}';
                }}
            }}
        """
        )

        # Update-Button klicken (falls vorhanden)
        update_btn = page.locator(
            "button:has-text('Update'), button.cart-update, .btn-update"
        )

        if await update_btn.count():
            await update_btn.first.click()
            await page.wait_for_timeout(1000)

        # Prüfe finale Menge im Warenkorb
        final_qty_element = page.locator("input[name*='quantity']").first

        if await final_qty_element.count():
            final_qty = await final_qty_element.input_value()

            try:
                final_qty_int = int(final_qty)

                # ERFOLGS-KRITERIUM: Menge sollte >= 0 sein
                assert final_qty_int >= 0, (
                    f"Negative quantity vulnerability! "
                    f"Attempted: {negative_qty}, Accepted: {final_qty_int}"
                )

            except ValueError:
                pass  # Nicht-numerischer Wert → validiert


@pytest.mark.pentest
@pytest.mark.business_logic
async def test_integer_overflow_quantity(page: Page, base_url: str):
    """
    Testet Integer Overflow bei Mengen-Eingaben.

    Angriffsziel: Mengen-Felder
    Erwartung: Extreme Werte sollten validiert werden
    OWASP: Business Logic Vulnerability

    Extreme Werte:
    - 2147483647 (32-bit max)
    - 9999999999 (sehr groß)
    """
    await page.goto(f"{base_url}")

    # Produkt zum Warenkorb
    product_link = page.locator("a.product-link, .product-item a").first

    if not await product_link.count():
        pytest.skip("No product found")

    await product_link.click()
    await add_to_cart_btn.count():
        await add_to_cart_btn.click()
        await page.wait_for_timeout(2000)

    await page.goto(f"{base_url}/checkout/cart")

    # Extreme Werte testen
    extreme_values = ["2147483647", "9999999999", "999999999999"]

    quantity_input = page.locator("input[name*='quantity']").first

    if not await quantity_input.count():
        pytest.skip("Quantity input not found")

    vulnerabilities = []

    for extreme_qty in extreme_values:
        await page.evaluate(
            f"""
            () => {{
                const qtyInput = document.querySelector('input[name*="quantity"]');
                if (qtyInput) {{
                    qtyInput.removeAttribute('max');
                    qtyInput.value = '{extreme_qty}';
                }}
            }}
        """
        )

        # Update
        update_btn = page.locator("button:has-text('Update'), .cart-update")

        if await update_btn.count():
            await update_btn.first.click()
            await page.wait_for_timeout(1000)

        # Prüfe, ob extreme Menge akzeptiert wurde
        content = await page.content()

        # Wenn Gesamtpreis extrem hoch → Vulnerability
        total_price = page.locator(".cart-total, .total-price").first

        if await total_price.count():
            total_text = await total_price.text_content()

            if "999999" in total_text or "NaN" in total_text or "Infinity" in total_text:
                vulnerabilities.append(
                    f"Extreme quantity {extreme_qty} caused overflow/error"
                )

    assert len(vulnerabilities) == 0, (
        f"Integer overflow vulnerability detected! "
        f"Issues: {'; '.join(vulnerabilities)}"
    )


@pytest.mark.pentest
@pytest.mark.business_logic
async def test_out_of_stock_bypass(page: Page, base_url: str):
    """
    Testet Inventory Bypass für ausverkaufte Produkte.

    Angriffsziel: "Add to Cart"-Button für ausverkaufte Produkte
    Erwartung: Server sollte Bestellung ablehnen
    OWASP: Business Logic Vulnerability

    Test-Ablauf:
    1. Finde ausverkauftes Produkt (oder simuliere)
    2. Via JavaScript: "Add to Cart"-Button enablen
    3. Produkt in Warenkorb legen
    4. Erwartung: Server lehnt ab mit "Out of Stock"-Fehler
    """
    pytest.skip("Test requires knowing which products are out of stock - implementation template")

    # Template-Implementation:
    # 1. await page.goto(f"{base_url}/product/sold-out-item")
    # 2. Check if button is disabled
    # 3. Enable button via JavaScript
    # 4. Click button
    # 5. Verify server rejects with "out of stock" error


@pytest.mark.pentest
@pytest.mark.business_logic
async def test_coupon_brute_force(page: Page, base_url: str):
    """
    Testet Coupon-Code Brute-Force.

    Angriffsziel: Gutscheincode-Eingabefeld
    Erwartung: Rate Limiting oder CAPTCHA nach mehreren Versuchen
    OWASP: Business Logic Vulnerability

    Test-Ablauf:
    1. Produkt zum Warenkorb hinzufügen
    2. Mehrere Gutscheincodes ausprobieren
    3. Prüfen auf Rate Limiting
    """
    await page.goto(f"{base_url}")

    # Produkt zum Warenkorb
    product_link = page.locator("a.product-link, .product-item a").first

    if not await product_link.count():
        pytest.skip("No product found")

    await product_link.click()

    add_to_cart_btn = page.locator("button:has-text('In den Warenkorb')").first

    if await add_to_cart_btn.count():
        await add_to_cart_btn.click()
        await page.wait_for_timeout(2000)

    # Zum Checkout/Warenkorb
    await page.goto(f"{base_url}/checkout/cart")

    # Gutscheinfeld finden
    coupon_input = page.locator(
        "input[name*='coupon'], input[name*='promo'], #coupon-code"
    ).first

    if not await coupon_input.count():
        # Versuche Checkout-Seite
        await page.goto(f"{base_url}/checkout")
        coupon_input = page.locator("input[name*='coupon'], input[name*='promo']").first

    if not await coupon_input.count():
        pytest.skip("Coupon input not found")

    # Brute-Force mit häufigen Codes
    rate_limit_triggered = False
    successful_codes = []

    for code in COMMON_COUPON_CODES[:20]:  # Nur erste 20 testen
        await coupon_input.fill(code)

        apply_btn = page.locator(
            "button:has-text('Apply'), button:has-text('Anwenden'), .btn-coupon"
        ).first

        if await apply_btn.count():
            await apply_btn.click()
            await page.wait_for_timeout(500)

        content = await page.content()
        content_lower = content.lower()

        # Prüfe auf erfolgreichen Code
        if "applied" in content_lower or "angewendet" in content_lower:
            successful_codes.append(code)

        # Prüfe auf Rate Limiting
        if "too many" in content_lower or "zu viele" in content_lower:
            rate_limit_triggered = True
            break

        if "captcha" in content_lower:
            rate_limit_triggered = True
            break

    # Wenn erfolgreiche Codes gefunden → Warnung (könnte legitim sein)
    if successful_codes:
        print(f"Warning: Found valid coupon codes: {', '.join(successful_codes)}")

    # ERFOLGS-KRITERIUM: Rate Limiting sollte aktiviert werden
    # (Optional - manche Shops haben kein Rate Limiting für Coupons)
    # assert rate_limit_triggered, "No rate limiting detected for coupon attempts"


@pytest.mark.pentest
@pytest.mark.business_logic
async def test_payment_bypass_direct_url(page: Page, base_url: str):
    """
    Testet Payment Bypass via direkte URL-Manipulation.

    Angriffsziel: Order-Completion ohne Zahlung
    Erwartung: Server sollte Payment validieren
    OWASP: Business Logic Vulnerability

    Test-Ablauf:
    1. Checkout-Prozess starten (bis Payment)
    2. Direkt zur "Order Completed"-Seite springen (ohne Payment)
    3. Erwartung: Server redirect zu Payment oder zeigt Fehler
    """
    # Produkt zum Warenkorb
    await page.goto(f"{base_url}")

    product_link = page.locator("a.product-link, .product-item a").first

    if await product_link.count():
        await product_link.click()

        add_to_cart_btn = page.locator("button:has-text('In den Warenkorb')").first

        if await add_to_cart_btn.count():
            await add_to_cart_btn.click()
            await page.wait_for_timeout(2000)

    # Direkt zur Finish-Seite springen (ohne Payment)
    await page.goto(f"{base_url}/checkout/finish")
    await page.wait_for_load_state("networkidle")

    current_url = page.url

    # ERFOLGS-KRITERIUM: Sollte zu Payment oder Cart redirecten
    assert (
        "/finish" not in current_url
        or "/payment" in current_url
        or "/cart" in current_url
        or "/login" in current_url
    ), (
        f"Payment bypass vulnerability! "
        f"Order completion page accessible without payment. URL: {current_url}"
    )


@pytest.mark.pentest
@pytest.mark.business_logic
@pytest.mark.slow
async def test_race_condition_single_use_coupon(browser: Browser, base_url: str):
    """
    Testet Race Condition bei Einmal-Gutscheinen.

    Angriffsziel: Einmal-Gutscheine mehrfach verwenden
    Erwartung: Nur 1 Verwendung sollte erfolgreich sein
    OWASP: Business Logic Vulnerability

    Test-Ablauf:
    1. 10 parallele Browser-Contexts
    2. Alle versuchen, denselben Einmal-Gutschein zu verwenden
    3. Erwartung: Nur 1 Erfolg, 9 Fehler
    """
    pytest.skip("Test requires valid single-use coupon code - implementation template")

    # Template-Implementation:
    # contexts = [await browser.new_context() for _ in range(10)]
    # pages = [await ctx.new_page() for ctx in contexts]

    # async def apply_coupon(page, code):
    #     # Add product to cart
    #     # Navigate to checkout
    #     # Apply coupon
    #     # Return success/failure

    # results = await asyncio.gather(*[apply_coupon(p, "SINGLE_USE_CODE") for p in pages])
    # successful = sum(1 for r in results if r == "success")

    # assert successful == 1, f"Race condition: {successful} orders with same coupon!"


@pytest.mark.pentest
@pytest.mark.business_logic
async def test_discount_stacking(page: Page, base_url: str):
    """
    Testet unbegrenztes Discount-Stacking.

    Angriffsziel: Mehrere Gutscheine kombinieren
    Erwartung: Nur erlaubte Kombinationen sollten funktionieren
    OWASP: Business Logic Vulnerability

    Test-Ablauf:
    1. Produkt zum Warenkorb
    2. Mehrere Gutscheine hintereinander anwenden
    3. Prüfen, ob Gesamtpreis negativ oder 0 wird
    """
    pytest.skip("Test requires valid coupon codes - implementation template")


@pytest.mark.pentest
@pytest.mark.business_logic
async def test_refund_manipulation(page: Page, base_url: str):
    """
    Testet Refund-Manipulation (mehr zurückbekommen als bezahlt).

    Angriffsziel: Refund-Prozess
    Erwartung: Refund sollte Kaufpreis nicht überschreiten
    OWASP: Business Logic Vulnerability
    """
    pytest.skip("Test requires order with refund capability - implementation template")
