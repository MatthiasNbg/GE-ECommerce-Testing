"""
Authentication Security Penetration Tests

Tests für:
- Brute-Force-Schutz
- Schwache Passwort-Policies
- Session Fixation
- Credential Enumeration
- Authentication Bypass

⚠️ WARNING: Diese Tests dürfen NUR auf autorisierten Systemen ausgeführt werden!
"""

import pytest
import asyncio
from playwright.async_api import Page, BrowserContext
from typing import List

from playwright_tests.utils.pentest_payloads import COMMON_PASSWORDS


@pytest.mark.pentest
@pytest.mark.auth
async def test_brute_force_protection(page: Page, base_url: str):
    """
    Testet, ob Login-Formular vor Brute-Force-Angriffen geschützt ist.

    Angriffsziel: Login-Formular
    Erwartung: Nach mehreren Fehlversuchen sollte:
              - Rate Limiting aktiviert werden
              - CAPTCHA erscheinen
              - Account temporär gesperrt werden
    OWASP: A07:2021 - Identification and Authentication Failures

    Test-Ablauf:
    1. 10 Login-Versuche mit falschen Passwörtern
    2. Prüfen auf Schutzmaßnahmen (Rate Limiting, CAPTCHA, Account Lock)
    """
    await page.goto(f"{base_url}/account/login")

    # Finde Login-Formular
    email_input = page.locator("input[name='email'], input[type='email'], #email")
    password_input = page.locator(
        "input[name='password'], input[type='password'], #password"
    )
    submit_button = page.locator("button[type='submit'], input[type='submit']")

    if not await email_input.count() or not await password_input.count():
        pytest.skip("Login form not found")

    test_email = "test@example.com"
    failed_attempts = 0
    protection_triggered = False
    protection_type = None

    # 10 Fehlversuche
    for i in range(10):
        await email_input.first.fill(test_email)
        await password_input.first.fill(f"wrong_password_{i}")

        await submit_button.first.click()
        await page.wait_for_timeout(500)

        content = await page.content()
        content_lower = content.lower()

        # Prüfe auf Schutzmaßnahmen
        if "captcha" in content_lower or "recaptcha" in content_lower:
            protection_triggered = True
            protection_type = "CAPTCHA"
            break

        if "too many" in content_lower or "zu viele" in content_lower:
            protection_triggered = True
            protection_type = "Rate Limiting"
            break

        if "locked" in content_lower or "gesperrt" in content_lower:
            protection_triggered = True
            protection_type = "Account Lock"
            break

        if "wait" in content_lower or "warten" in content_lower:
            protection_triggered = True
            protection_type = "Throttling"
            break

        failed_attempts += 1

    # ERFOLGS-KRITERIUM: Schutzmaßnahme sollte aktiviert werden
    assert protection_triggered, (
        f"No brute-force protection detected after {failed_attempts} failed login attempts! "
        f"Expected: Rate Limiting, CAPTCHA, or Account Lock"
    )

    print(f"✓ Brute-force protection active: {protection_type}")


@pytest.mark.pentest
@pytest.mark.auth
async def test_weak_password_policy(page: Page, base_url: str):
    """
    Testet, ob schwache Passwörter bei der Registrierung akzeptiert werden.

    Angriffsziel: Registrierungs-Formular
    Erwartung: Schwache Passwörter sollten abgelehnt werden
    OWASP: A07:2021 - Identification and Authentication Failures

    Schwache Passwörter:
    - "123456", "password", "abc123"
    - Zu kurz (< 8 Zeichen)
    - Keine Komplexitätsanforderungen
    """
    # Navigiere zu Registrierung
    try:
        await page.goto(f"{base_url}/account/register")
    except Exception:
        pytest.skip("Registration page not accessible")

    weak_passwords = ["123456", "password", "abc", "12345678", "qwerty"]

    accepted_weak_passwords = []

    for weak_pwd in weak_passwords:
        # Finde Passwort-Feld
        password_input = page.locator(
            "input[name='password'], input[type='password']"
        ).first

        if not await password_input.count():
            pytest.skip("Password field not found in registration form")

        await password_input.fill(weak_pwd)

        # Prüfe auf Validierungsfehler
        await page.wait_for_timeout(500)

        # Suche nach Validierungsmeldungen
        error_message = await page.locator(
            ".error, .invalid-feedback, .form-error, [role='alert']"
        ).all_text_contents()

        error_text = " ".join(error_message).lower()

        # Wenn kein Fehler → schwaches Passwort wurde akzeptiert
        if not ("password" in error_text or "passwort" in error_text):
            accepted_weak_passwords.append(weak_pwd)

    # ERFOLGS-KRITERIUM: Keine schwachen Passwörter sollten akzeptiert werden
    assert len(accepted_weak_passwords) == 0, (
        f"Weak password policy detected! "
        f"These weak passwords were accepted: {', '.join(accepted_weak_passwords)}"
    )


@pytest.mark.pentest
@pytest.mark.auth
async def test_username_enumeration(page: Page, base_url: str):
    """
    Testet, ob User-Enumeration möglich ist (Username/Email-Erkennung).

    Angriffsziel: Login-Formular, "Forgot Password"-Funktion
    Erwartung: Gleiche Fehlermeldung für existierende/nicht-existierende User
    OWASP: A07:2021 - Identification and Authentication Failures

    Angriffsszenario:
    - Login mit existierender Email → "Wrong password"
    - Login mit nicht-existierender Email → "User not found"
    → Angreifer kann gültige Emails ermitteln
    """
    await page.goto(f"{base_url}/account/login")

    # Teste mit nicht-existierender Email
    email_input = page.locator("input[name='email'], input[type='email']").first
    password_input = page.locator("input[name='password'], input[type='password']").first
    submit_button = page.locator("button[type='submit']").first

    if not await email_input.count():
        pytest.skip("Login form not found")

    # Non-existent user
    await email_input.fill("nonexistent_user_12345@example.com")
    await password_input.fill("any_password")
    await submit_button.click()
    await page.wait_for_timeout(1000)

    error_msg_nonexistent = await page.locator(
        ".error, .alert, .message, [role='alert']"
    ).all_text_contents()
    error_nonexistent = " ".join(error_msg_nonexistent).lower()

    # Existing user (falls bekannt) - hier Dummy
    await page.goto(f"{base_url}/account/login")
    await email_input.fill("admin@example.com")  # Vermutlich existierender User
    await password_input.fill("wrong_password")
    await submit_button.click()
    await page.wait_for_timeout(1000)

    error_msg_existing = await page.locator(
        ".error, .alert, .message, [role='alert']"
    ).all_text_contents()
    error_existing = " ".join(error_msg_existing).lower()

    # Prüfe, ob Fehlermeldungen unterschiedlich sind
    enumeration_possible = False

    if "not found" in error_nonexistent or "nicht gefunden" in error_nonexistent:
        if "wrong password" in error_existing or "falsches passwort" in error_existing:
            enumeration_possible = True

    # ERFOLGS-KRITERIUM: Fehlermeldungen sollten identisch/generisch sein
    if enumeration_possible:
        pytest.fail(
            "Username enumeration possible! "
            "Different error messages for existing/non-existing users."
        )


@pytest.mark.pentest
@pytest.mark.auth
async def test_session_fixation(page: Page, context: BrowserContext, base_url: str):
    """
    Testet auf Session Fixation-Anfälligkeit.

    Angriffsziel: Login-Prozess
    Erwartung: Session-ID sollte nach Login erneuert werden
    OWASP: A07:2021 - Identification and Authentication Failures

    Test-Ablauf:
    1. Session-ID vor Login speichern
    2. Login durchführen
    3. Session-ID nach Login prüfen
    4. Erwartung: Session-ID hat sich geändert
    """
    await page.goto(f"{base_url}")

    # Session-Cookie vor Login
    cookies_before = await context.cookies()
    session_cookie_before = None

    for cookie in cookies_before:
        if "session" in cookie["name"].lower() or "phpsessid" in cookie["name"].lower():
            session_cookie_before = cookie["value"]
            break

    if not session_cookie_before:
        pytest.skip("No session cookie found before login")

    # Login durchführen (benötigt gültige Test-Credentials)
    # Hier Dummy-Login, in realer Umgebung mit echten Test-Credentials
    await page.goto(f"{base_url}/account/login")

    # Falls kein Login-Formular → Skip
    if not await page.locator("input[name='email']").count():
        pytest.skip("Cannot test session fixation without login form")

    # Dummy-Login (muss für echten Test angepasst werden)
    # await page.fill("input[name='email']", "test@example.com")
    # await page.fill("input[name='password']", "correct_password")
    # await page.click("button[type='submit']")

    # Session-Cookie nach Login
    cookies_after = await context.cookies()
    session_cookie_after = None

    for cookie in cookies_after:
        if "session" in cookie["name"].lower() or "phpsessid" in cookie["name"].lower():
            session_cookie_after = cookie["value"]
            break

    # ERFOLGS-KRITERIUM: Session-ID sollte sich geändert haben
    # (Dieser Test ist ein Beispiel - in Praxis nur mit echtem Login testbar)
    # assert session_cookie_before != session_cookie_after, (
    #     f"Session Fixation vulnerability! "
    #     f"Session ID not renewed after login."
    # )

    pytest.skip("Test requires valid login credentials - implementation template provided")


@pytest.mark.pentest
@pytest.mark.auth
async def test_logout_invalidates_session(page: Page, context: BrowserContext, base_url: str):
    """
    Testet, ob Logout die Session tatsächlich invalidiert.

    Angriffsziel: Logout-Funktion
    Erwartung: Nach Logout sollte Session-Cookie gelöscht/ungültig sein
    OWASP: A07:2021 - Identification and Authentication Failures

    Test-Ablauf:
    1. Login (Session erhalten)
    2. Logout durchführen
    3. Prüfen, ob Session-Cookie gelöscht wurde
    4. Versuch, mit altem Session-Cookie auf geschützte Seite zuzugreifen
    """
    # Hinweis: Dieser Test benötigt valide Login-Credentials
    pytest.skip("Test requires valid login credentials - implementation template provided")

    # Template-Implementation:
    # 1. Login und Session-Cookie speichern
    # 2. Logout
    # 3. Prüfen, ob Cookie gelöscht wurde
    # 4. Cookie manuell wieder setzen
    # 5. Versuch, auf geschützte Seite zuzugreifen
    # 6. Erwartung: Redirect zu Login (Session invalid)


@pytest.mark.pentest
@pytest.mark.auth
async def test_authentication_bypass_via_sql_injection(page: Page, base_url: str):
    """
    Testet klassischen SQL Injection Authentication Bypass.

    Angriffsziel: Login-Formular
    Erwartung: SQL Injection sollte nicht zum Bypass führen
    OWASP: A03:2021 - Injection + A07:2021 - Authentication Failures

    Bekannte Bypass-Payloads:
    - admin' OR '1'='1
    - admin'--
    - ' OR 1=1--
    """
    await page.goto(f"{base_url}/account/login")

    bypass_payloads = [
        "admin' OR '1'='1",
        "admin'--",
        "' OR 1=1--",
        "' OR 'a'='a",
        "admin' /*",
    ]

    for payload in bypass_payloads:
        email_input = page.locator("input[name='email'], input[type='email']").first
        password_input = page.locator("input[name='password']").first
        submit_button = page.locator("button[type='submit']").first

        if not await email_input.count():
            pytest.skip("Login form not found")

        await email_input.fill(payload)
        await password_input.fill(payload)
        await submit_button.click()
        await page.wait_for_timeout(1000)

        # Prüfe, ob Login erfolgreich war (Bypass!)
        current_url = page.url

        # Wenn URL zu /account oder /dashboard wechselt → Bypass erfolgreich
        if "/account" in current_url or "/dashboard" in current_url:
            pytest.fail(
                f"Authentication bypass via SQL Injection! "
                f"Payload '{payload}' successfully bypassed login."
            )

        # Zurück zu Login für nächsten Versuch
        await page.goto(f"{base_url}/account/login")


@pytest.mark.pentest
@pytest.mark.auth
@pytest.mark.slow
async def test_password_reset_token_predictability(page: Page, base_url: str):
    """
    Testet, ob Password-Reset-Tokens vorhersagbar sind.

    Angriffsziel: "Forgot Password"-Funktion
    Erwartung: Tokens sollten kryptographisch sicher und nicht vorhersagbar sein
    OWASP: A02:2021 - Cryptographic Failures

    Hinweis: Dieser Test benötigt Zugriff auf generierte Reset-Tokens
    (z.B. via Test-Email-Server oder Log-Files).
    """
    pytest.skip("Test requires access to generated reset tokens - implementation template")

    # Template-Implementation:
    # 1. 10 Password-Reset-Requests für verschiedene Accounts
    # 2. Reset-Tokens sammeln
    # 3. Tokens auf Muster analysieren:
    #    - Sind sie sequenziell? (123456, 123457, ...)
    #    - Basieren sie auf Timestamp?
    #    - Sind sie zu kurz? (< 128 Bit)
    # 4. Bei erkanntem Muster → Test schlägt fehl


@pytest.mark.pentest
@pytest.mark.auth
async def test_default_credentials(page: Page, base_url: str):
    """
    Testet auf häufige Default-Credentials.

    Angriffsziel: Admin-Login, System-Accounts
    Erwartung: Keine Default-Credentials sollten funktionieren
    OWASP: A07:2021 - Identification and Authentication Failures

    Häufige Default-Logins:
    - admin / admin
    - admin / password
    - root / root
    - administrator / administrator
    """
    default_credentials = [
        ("admin", "admin"),
        ("admin", "password"),
        ("admin", "12345"),
        ("administrator", "administrator"),
        ("root", "root"),
        ("test", "test"),
    ]

    await page.goto(f"{base_url}/account/login")

    for username, password in default_credentials:
        email_input = page.locator("input[name='email'], input[name='username']").first
        password_input = page.locator("input[name='password']").first
        submit_button = page.locator("button[type='submit']").first

        if not await email_input.count():
            pytest.skip("Login form not found")

        await email_input.fill(username)
        await password_input.fill(password)
        await submit_button.click()
        await page.wait_for_timeout(1000)

        # Prüfe, ob Login erfolgreich
        current_url = page.url

        if "/account" in current_url or "/dashboard" in current_url or "/admin" in current_url:
            pytest.fail(
                f"Default credentials accepted! "
                f"Username: {username}, Password: {password}"
            )

        # Zurück zu Login
        await page.goto(f"{base_url}/account/login")
