"""
Injection Attack Penetration Tests

Tests für:
- SQL Injection
- Cross-Site Scripting (XSS)
- Command Injection
- Path Traversal
- LDAP Injection

⚠️ WARNING: Diese Tests dürfen NUR auf autorisierten Systemen ausgeführt werden!
"""

import pytest
from playwright.async_api import Page, expect, Dialog
from typing import List

from playwright_tests.utils.pentest_payloads import (
    SQL_INJECTION_PAYLOADS,
    XSS_PAYLOADS,
    COMMAND_INJECTION_PAYLOADS,
    PATH_TRAVERSAL_PAYLOADS,
    SQL_ERROR_PATTERNS,
    COMMAND_ERROR_PATTERNS,
    is_vulnerability_detected,
)


@pytest.mark.pentest
@pytest.mark.injection
async def test_sql_injection_in_search(page: Page, base_url: str):
    """
    Testet Produktsuche auf SQL Injection-Anfälligkeit.

    Angriffsziel: Produktsuche-Funktion
    Erwartung: Alle SQL-Injection-Payloads sollten escaped/validiert werden
    OWASP: A03:2021 - Injection

    Test-Ablauf:
    1. Für jeden SQL-Injection-Payload:
       - Eingabe in Suchfeld
       - Absenden des Formulars
       - Prüfung der Antwort auf SQL-Fehler
    2. Bei erkanntem SQL-Fehler → Test schlägt fehl (Vulnerability!)
    """
    vulnerabilities_found = []

    # Zur Suchseite navigieren
    await page.goto(f"{base_url}/search")

    for payload in SQL_INJECTION_PAYLOADS:
        # Suchfeld finden und Payload eingeben
        search_input = page.locator("input[name='search'], input[type='search'], #search")

        if not await search_input.count():
            pytest.skip("Search input not found on page")

        await search_input.first.fill(payload)

        # Such-Button finden und klicken
        search_button = page.locator(
            "button[type='submit'], button.search-button, input[type='submit']"
        )

        if await search_button.count():
            await search_button.first.click()
        else:
            # Enter drücken, wenn kein Button
            await search_input.first.press("Enter")

        # Auf Antwort warten
        await page.wait_for_load_state("networkidle", timeout=5000)

        # Seiteninhalt prüfen
        content = await page.content()

        # Prüfe auf SQL-Fehler
        is_vulnerable, detection_msg = is_vulnerability_detected(content, "sql")

        if is_vulnerable:
            vulnerabilities_found.append({
                "payload": payload,
                "detection": detection_msg,
            })

    # Finale Assertion
    assert len(vulnerabilities_found) == 0, (
        f"SQL Injection vulnerability detected in search! "
        f"Found {len(vulnerabilities_found)} vulnerable payload(s):\n"
        + "\n".join([f"  - {v['payload']}: {v['detection']}" for v in vulnerabilities_found])
    )


@pytest.mark.pentest
@pytest.mark.injection
async def test_xss_in_checkout_fields(page: Page, base_url: str):
    """
    Testet Checkout-Formulare auf XSS-Anfälligkeit.

    Angriffsziel: Adress-Eingabefelder im Checkout
    Erwartung: Alle XSS-Payloads sollten escaped werden
    OWASP: A03:2021 - Injection

    Test-Ablauf:
    1. Navigation zum Checkout
    2. Für jeden XSS-Payload:
       - Eingabe in verschiedene Formularfelder
       - Dialog-Handler registrieren (erkennt ausgeführtes JavaScript)
       - Prüfen, ob Script-Tags im HTML escaped sind
    """
    # Dialog-Handler: Erkennt, wenn JavaScript ausgeführt wird
    dialog_triggered = []

    async def handle_dialog(dialog: Dialog):
        dialog_triggered.append(dialog.message)
        await dialog.dismiss()

    page.on("dialog", handle_dialog)

    # Produkt zum Warenkorb hinzufügen (Voraussetzung für Checkout)
    try:
        await page.goto(f"{base_url}")

        # Versuche, ein Produkt zu finden und zum Warenkorb hinzuzufügen
        product_link = page.locator("a.product-link, .product-item a").first
        if await product_link.count():
            await product_link.click()

            add_to_cart_btn = page.locator(
                "button:has-text('In den Warenkorb'), button.add-to-cart"
            ).first

            if await add_to_cart_btn.count():
                await add_to_cart_btn.click()
                await page.wait_for_timeout(1000)

    except Exception:
        pytest.skip("Could not add product to cart - skipping checkout XSS test")

    # Zum Checkout navigieren
    await page.goto(f"{base_url}/checkout")

    # Checkout-Formular-Felder identifizieren
    form_fields = [
        "input[name='firstName'], input#firstName",
        "input[name='lastName'], input#lastName",
        "input[name='street'], input#street",
        "input[name='city'], input#city",
        "input[name='company'], input#company",
    ]

    vulnerabilities_found = []

    for payload in XSS_PAYLOADS[:5]:  # Nur erste 5 Payloads testen (Performance)
        for field_selector in form_fields:
            field = page.locator(field_selector).first

            if not await field.count():
                continue

            # Payload eingeben
            await field.fill(payload)
            await page.wait_for_timeout(500)

            # Prüfe, ob Dialog ausgelöst wurde
            if dialog_triggered:
                vulnerabilities_found.append({
                    "payload": payload,
                    "field": field_selector,
                    "detection": f"JavaScript alert triggered: {dialog_triggered[-1]}",
                })
                dialog_triggered.clear()

            # Prüfe, ob Payload im HTML escaped ist
            try:
                field_value = await field.input_value()
                page_content = await page.content()

                # Wenn <script> unescaped im HTML → Vulnerability
                if "<script>" in page_content and field_value in page_content:
                    vulnerabilities_found.append({
                        "payload": payload,
                        "field": field_selector,
                        "detection": "Unescaped script tag in HTML",
                    })
            except Exception:
                pass

    # Finale Assertion
    assert len(vulnerabilities_found) == 0, (
        f"XSS vulnerability detected in checkout! "
        f"Found {len(vulnerabilities_found)} vulnerable payload(s):\n"
        + "\n".join(
            [
                f"  - {v['payload']} in {v['field']}: {v['detection']}"
                for v in vulnerabilities_found
            ]
        )
    )


@pytest.mark.pentest
@pytest.mark.injection
async def test_xss_in_product_search_results(page: Page, base_url: str):
    """
    Testet Produktsuche auf Reflected XSS.

    Angriffsziel: Suchfeld → Ergebnisseite
    Erwartung: XSS-Payloads werden escaped in Suchergebnissen angezeigt
    OWASP: A03:2021 - Injection
    """
    dialog_triggered = []

    async def handle_dialog(dialog: Dialog):
        dialog_triggered.append(dialog.message)
        await dialog.dismiss()

    page.on("dialog", handle_dialog)

    vulnerabilities_found = []

    for payload in XSS_PAYLOADS[:5]:
        await page.goto(f"{base_url}/search?q={payload}")
        await page.wait_for_timeout(1000)

        # Prüfe, ob Dialog ausgelöst wurde
        if dialog_triggered:
            vulnerabilities_found.append({
                "payload": payload,
                "detection": f"JavaScript alert triggered: {dialog_triggered[-1]}",
            })
            dialog_triggered.clear()

        # Prüfe HTML-Content
        content = await page.content()
        if "<script>" in content:
            vulnerabilities_found.append({
                "payload": payload,
                "detection": "Unescaped script tag in search results",
            })

    assert len(vulnerabilities_found) == 0, (
        f"Reflected XSS vulnerability in search! "
        f"Vulnerable payloads:\n"
        + "\n".join([f"  - {v['payload']}: {v['detection']}" for v in vulnerabilities_found])
    )


@pytest.mark.pentest
@pytest.mark.injection
async def test_command_injection_in_file_operations(page: Page, base_url: str):
    """
    Testet Datei-Operationen auf Command Injection.

    Angriffsziel: Datei-Download, Export-Funktionen
    Erwartung: Shell-Befehle sollten nicht ausgeführt werden
    OWASP: A03:2021 - Injection

    Test-Ablauf:
    1. Versuche, Command Injection-Payloads in Dateinamen zu injizieren
    2. Prüfe, ob Shell-Befehle ausgeführt wurden (z.B. /etc/passwd im Response)
    """
    vulnerabilities_found = []

    for payload in COMMAND_INJECTION_PAYLOADS[:5]:
        # Beispiel: Dateiname mit Command Injection
        filename = f"invoice{payload}.pdf"

        # Teste verschiedene Download-Endpoints
        endpoints = [
            f"/order/download?file={filename}",
            f"/export?filename={filename}",
            f"/download/{filename}",
        ]

        for endpoint in endpoints:
            try:
                response = await page.goto(f"{base_url}{endpoint}", wait_until="load")

                if not response:
                    continue

                content = await page.content()

                # Prüfe auf Command Execution
                is_vulnerable, detection_msg = is_vulnerability_detected(content, "command")

                if is_vulnerable:
                    vulnerabilities_found.append({
                        "payload": payload,
                        "endpoint": endpoint,
                        "detection": detection_msg,
                    })

            except Exception:
                # Endpoint existiert möglicherweise nicht → ignorieren
                pass

    # Wenn keine Endpoints gefunden wurden, Test überspringen
    if not vulnerabilities_found and len(vulnerabilities_found) == 0:
        pytest.skip("No file download endpoints found for testing")

    assert len(vulnerabilities_found) == 0, (
        f"Command Injection vulnerability detected! "
        f"Vulnerable payloads:\n"
        + "\n".join(
            [
                f"  - {v['payload']} at {v['endpoint']}: {v['detection']}"
                for v in vulnerabilities_found
            ]
        )
    )


@pytest.mark.pentest
@pytest.mark.injection
async def test_path_traversal_in_file_access(page: Page, base_url: str):
    """
    Testet Datei-Zugriffe auf Path Traversal.

    Angriffsziel: Datei-Download, statische Assets
    Erwartung: Zugriff außerhalb des vorgesehenen Verzeichnisses blockiert
    OWASP: A01:2021 - Broken Access Control

    Test-Ablauf:
    1. Versuche, auf /etc/passwd oder Windows-Systemdateien zuzugreifen
    2. Prüfe, ob Dateien erfolgreich geladen wurden
    """
    vulnerabilities_found = []

    for payload in PATH_TRAVERSAL_PAYLOADS[:5]:
        endpoints = [
            f"/download?file={payload}",
            f"/assets/{payload}",
            f"/media/{payload}",
            f"/files/{payload}",
        ]

        for endpoint in endpoints:
            try:
                response = await page.goto(f"{base_url}{endpoint}", wait_until="load")

                if not response:
                    continue

                content = await page.content()

                # Prüfe auf erfolgreichen Path Traversal
                is_vulnerable, detection_msg = is_vulnerability_detected(
                    content, "path_traversal"
                )

                if is_vulnerable:
                    vulnerabilities_found.append({
                        "payload": payload,
                        "endpoint": endpoint,
                        "detection": detection_msg,
                    })

            except Exception:
                pass

    if not vulnerabilities_found and len(vulnerabilities_found) == 0:
        pytest.skip("No file access endpoints found for testing")

    assert len(vulnerabilities_found) == 0, (
        f"Path Traversal vulnerability detected! "
        f"Vulnerable payloads:\n"
        + "\n".join(
            [
                f"  - {v['payload']} at {v['endpoint']}: {v['detection']}"
                for v in vulnerabilities_found
            ]
        )
    )


@pytest.mark.pentest
@pytest.mark.injection
@pytest.mark.skip(reason="Requires API endpoint knowledge")
async def test_nosql_injection_in_api(page: Page, base_url: str):
    """
    Testet API-Endpoints auf NoSQL Injection (MongoDB, etc.).

    Angriffsziel: REST API mit NoSQL-Backend
    Erwartung: NoSQL-Operatoren sollten escaped werden
    OWASP: A03:2021 - Injection

    Hinweis: Dieser Test erfordert Kenntnis der API-Endpoints und ist
    standardmäßig übersprungen. Passen Sie die Endpoints an Ihre API an.
    """
    pass  # Implementation abhängig von der konkreten API-Struktur
