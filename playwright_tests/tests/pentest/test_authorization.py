"""
Authorization & Access Control Penetration Tests

Tests für:
- IDOR (Insecure Direct Object References)
- Privilege Escalation
- Horizontal/Vertical Access Control Bypass
- Missing Function Level Access Control

⚠️ WARNING: Diese Tests dürfen NUR auf autorisierten Systemen ausgeführt werden!
"""

import pytest
from playwright.async_api import Page, BrowserContext


@pytest.mark.pentest
@pytest.mark.authz
async def test_idor_order_access(page: Page, context: BrowserContext, base_url: str):
    """
    Testet IDOR-Vulnerability bei Bestellungen.

    Angriffsziel: Order-Detail-Seiten
    Erwartung: User kann nur eigene Bestellungen einsehen
    OWASP: A01:2021 - Broken Access Control

    Test-Ablauf:
    1. Als User A: Bestellung erstellen (Order-ID merken)
    2. Als User B: Versuchen, Order von User A zu öffnen
    3. Erwartung: 403 Forbidden oder 404 Not Found
    """
    # Hinweis: Benötigt zwei verschiedene User-Accounts
    pytest.skip("Test requires two user accounts - implementation template provided")

    # Template-Implementation:
    # User A: Login und Bestellung erstellen
    # await login_as_user_a(page)
    # order_id_a = await create_order(page)

    # User B: Neuer Browser-Context (neue Session)
    # page_b = await context.new_page()
    # await login_as_user_b(page_b)

    # Versuch, Order von User A zu öffnen
    # response = await page_b.goto(f"{base_url}/order/{order_id_a}")

    # ERFOLGS-KRITERIUM: 403 oder 404
    # assert response.status in [403, 404], (
    #     f"IDOR vulnerability! User B can access User A's order. "
    #     f"Status: {response.status}"
    # )


@pytest.mark.pentest
@pytest.mark.authz
async def test_idor_sequential_order_ids(page: Page, base_url: str):
    """
    Testet, ob sequenzielle Order-IDs ausgenutzt werden können.

    Angriffsziel: Order-URLs mit sequenziellen IDs
    Erwartung: Fremde Orders sollten nicht zugänglich sein
    OWASP: A01:2021 - Broken Access Control

    Test-Ablauf:
    1. Versuche, sequenzielle Order-IDs zu erraten
    2. Prüfe, ob fremde Bestellungen sichtbar sind
    """
    # Teste sequenzielle IDs
    test_order_ids = [10000, 10001, 10002, 10003, 10004]

    accessible_orders = []

    for order_id in test_order_ids:
        response = await page.goto(f"{base_url}/order/{order_id}", wait_until="load")

        # Wenn Status 200 → Order ist zugänglich
        if response and response.status == 200:
            content = await page.content()

            # Prüfe, ob tatsächlich Order-Details angezeigt werden
            if "order" in content.lower() or "bestellung" in content.lower():
                accessible_orders.append(order_id)

    # WARNUNG: Wenn Orders zugänglich sind, könnte IDOR vorliegen
    # (Kann auch legitim sein, wenn User eingeloggt ist)
    if len(accessible_orders) > 0:
        print(
            f"Warning: {len(accessible_orders)} orders accessible via sequential IDs. "
            f"Verify if these belong to current user or if IDOR vulnerability exists."
        )


@pytest.mark.pentest
@pytest.mark.authz
async def test_admin_panel_access_without_auth(page: Page, base_url: str):
    """
    Testet, ob Admin-Panel ohne Authentifizierung zugänglich ist.

    Angriffsziel: Admin-Bereiche
    Erwartung: Redirect zu Login oder 403 Forbidden
    OWASP: A01:2021 - Broken Access Control

    Häufige Admin-Pfade:
    - /admin
    - /administrator
    - /backend
    - /wp-admin
    - /admin/dashboard
    """
    admin_paths = [
        "/admin",
        "/admin/",
        "/administrator",
        "/backend",
        "/admin/dashboard",
        "/admin/products",
        "/admin/orders",
        "/admin/users",
        "/api/admin",
    ]

    accessible_paths = []

    for path in admin_paths:
        try:
            response = await page.goto(f"{base_url}{path}", wait_until="load", timeout=5000)

            if not response:
                continue

            status = response.status
            current_url = page.url

            # Wenn Status 200 UND nicht zu Login redirected → potenziell zugänglich
            if status == 200 and "/login" not in current_url.lower():
                content = await page.content()

                # Prüfe, ob tatsächlich Admin-Interface sichtbar
                if any(
                    keyword in content.lower()
                    for keyword in ["dashboard", "admin", "administration", "verwaltung"]
                ):
                    accessible_paths.append(path)

        except Exception:
            # Timeout oder andere Fehler → ignorieren
            pass

    # ERFOLGS-KRITERIUM: Keine Admin-Pfade sollten ohne Auth zugänglich sein
    assert len(accessible_paths) == 0, (
        f"Admin panel accessible without authentication! "
        f"Accessible paths: {', '.join(accessible_paths)}"
    )


@pytest.mark.pentest
@pytest.mark.authz
async def test_api_endpoints_without_auth(page: Page, base_url: str):
    """
    Testet, ob API-Endpoints ohne Authentifizierung zugänglich sind.

    Angriffsziel: REST API-Endpoints
    Erwartung: Geschützte Endpoints sollten 401 Unauthorized zurückgeben
    OWASP: A01:2021 - Broken Access Control

    Häufige API-Endpoints:
    - /api/users
    - /api/orders
    - /api/products
    - /api/admin/*
    """
    api_endpoints = [
        "/api/users",
        "/api/user/profile",
        "/api/orders",
        "/api/admin/users",
        "/api/admin/config",
        "/api/customers",
        "/store-api/account/customer",
    ]

    accessible_endpoints = []

    for endpoint in api_endpoints:
        try:
            # API-Request ohne Auth-Token
            response = await page.request.get(f"{base_url}{endpoint}")

            status = response.status

            # Wenn Status 200 → Endpoint ist ohne Auth zugänglich
            if status == 200:
                try:
                    data = await response.json()
                    # Wenn tatsächlich Daten zurückkommen → Vulnerability
                    if data and len(str(data)) > 10:
                        accessible_endpoints.append(endpoint)
                except Exception:
                    pass

        except Exception:
            pass

    # ERFOLGS-KRITERIUM: Geschützte Endpoints sollten 401 zurückgeben
    assert len(accessible_endpoints) == 0, (
        f"Protected API endpoints accessible without authentication! "
        f"Accessible: {', '.join(accessible_endpoints)}"
    )


@pytest.mark.pentest
@pytest.mark.authz
async def test_horizontal_privilege_escalation(
    page: Page, context: BrowserContext, base_url: str
):
    """
    Testet Horizontal Privilege Escalation (User kann Daten anderer User ändern).

    Angriffsziel: User-Profile, Adressen, etc.
    Erwartung: User A kann Profile von User B nicht ändern
    OWASP: A01:2021 - Broken Access Control

    Test-Ablauf:
    1. Als User A einloggen, User-ID ermitteln
    2. Versuchen, Profil von User B zu ändern (via API oder Formular)
    3. Erwartung: 403 Forbidden
    """
    pytest.skip("Test requires two user accounts - implementation template provided")

    # Template:
    # 1. Login als User A
    # 2. User-ID von User B ermitteln (z.B. /api/users)
    # 3. PUT/PATCH-Request an /api/users/{user_b_id}
    # 4. Erwartung: 403 Forbidden


@pytest.mark.pentest
@pytest.mark.authz
async def test_vertical_privilege_escalation(page: Page, base_url: str):
    """
    Testet Vertical Privilege Escalation (User erhält Admin-Rechte).

    Angriffsziel: User-Rolle-Änderungen
    Erwartung: Normale User können sich nicht zu Admins machen
    OWASP: A01:2021 - Broken Access Control

    Angriffsszenario:
    - User ändert eigenes Profil und setzt "role": "admin"
    - User manipuliert HTTP-Request: is_admin=true
    """
    pytest.skip("Test requires user account - implementation template provided")

    # Template:
    # 1. Login als normaler User
    # 2. Profile-Edit-Request abfangen (via Playwright Request Interception)
    # 3. "role": "admin" oder "is_admin": true hinzufügen
    # 4. Request senden
    # 5. Prüfen, ob User jetzt Admin-Rechte hat
    # 6. Erwartung: Server sollte Rolle-Änderung ignorieren/blockieren


@pytest.mark.pentest
@pytest.mark.authz
async def test_missing_function_level_access_control(page: Page, base_url: str):
    """
    Testet, ob administrative Funktionen ohne entsprechende Rechte aufrufbar sind.

    Angriffsziel: Admin-Funktionen (Delete User, Change Settings, etc.)
    Erwartung: Normale User sollten Admin-Funktionen nicht aufrufen können
    OWASP: A01:2021 - Broken Access Control

    Test-Ablauf:
    1. Als Gast/Normal-User: Versuche, Admin-Funktionen aufzurufen
    2. Erwartung: 403 Forbidden oder 401 Unauthorized
    """
    admin_functions = [
        {"method": "DELETE", "url": "/api/users/123"},
        {"method": "POST", "url": "/api/admin/settings"},
        {"method": "PUT", "url": "/api/products/123/disable"},
        {"method": "DELETE", "url": "/api/orders/123"},
    ]

    accessible_functions = []

    for func in admin_functions:
        try:
            if func["method"] == "DELETE":
                response = await page.request.delete(f"{base_url}{func['url']}")
            elif func["method"] == "POST":
                response = await page.request.post(f"{base_url}{func['url']}")
            elif func["method"] == "PUT":
                response = await page.request.put(f"{base_url}{func['url']}")
            else:
                continue

            # Wenn nicht 401/403 → potenziell zugänglich
            if response.status not in [401, 403, 404]:
                accessible_functions.append(f"{func['method']} {func['url']}")

        except Exception:
            pass

    # ERFOLGS-KRITERIUM: Admin-Funktionen sollten geschützt sein
    assert len(accessible_functions) == 0, (
        f"Admin functions accessible without proper authorization! "
        f"Accessible: {', '.join(accessible_functions)}"
    )


@pytest.mark.pentest
@pytest.mark.authz
async def test_forced_browsing_to_restricted_pages(page: Page, base_url: str):
    """
    Testet Forced Browsing zu geschützten Seiten.

    Angriffsziel: Direkte URLs zu geschützten Ressourcen
    Erwartung: Redirect zu Login oder 403
    OWASP: A01:2021 - Broken Access Control

    Beispiel-URLs:
    - /account/orders (sollte Login erfordern)
    - /admin (sollte Admin-Rechte erfordern)
    - /checkout/confirm (sollte Warenkorb erfordern)
    """
    protected_pages = [
        "/account",
        "/account/orders",
        "/account/profile",
        "/account/addresses",
        "/checkout/confirm",
        "/admin",
        "/admin/dashboard",
    ]

    accessible_pages = []

    for page_url in protected_pages:
        response = await page.goto(f"{base_url}{page_url}", wait_until="load")

        if not response:
            continue

        current_url = page.url

        # Wenn nicht zu Login redirected UND Status 200
        if response.status == 200 and "/login" not in current_url.lower():
            # Prüfe, ob tatsächlich Inhalte angezeigt werden (nicht nur leere Seite)
            content = await page.content()

            if len(content) > 1000:  # Mehr als leere Seite
                accessible_pages.append(page_url)

    # ERFOLGS-KRITERIUM: Geschützte Seiten sollten Login erfordern
    if len(accessible_pages) > 0:
        print(
            f"Warning: {len(accessible_pages)} protected pages accessible without login. "
            f"Verify if this is intended: {', '.join(accessible_pages)}"
        )


@pytest.mark.pentest
@pytest.mark.authz
async def test_cors_misconfiguration(page: Page, base_url: str):
    """
    Testet auf CORS-Fehlkonfigurationen.

    Angriffsziel: API-Endpoints
    Erwartung: CORS sollte restriktiv konfiguriert sein
    OWASP: A05:2021 - Security Misconfiguration

    Gefährliche CORS-Konfigurationen:
    - Access-Control-Allow-Origin: * (für Endpoints mit sensiblen Daten)
    - Access-Control-Allow-Credentials: true + ACAO: *
    - ACAO reflektiert beliebige Origin
    """
    api_endpoints = ["/api/user/profile", "/api/orders", "/api/account"]

    cors_issues = []

    for endpoint in api_endpoints:
        try:
            # Request mit Origin-Header
            response = await page.request.get(
                f"{base_url}{endpoint}",
                headers={"Origin": "https://evil.com"},
            )

            headers = response.headers

            # Prüfe CORS-Header
            acao = headers.get("access-control-allow-origin", "")
            acac = headers.get("access-control-allow-credentials", "")

            # Gefährlich: ACAO: * + Credentials: true
            if acao == "*" and acac.lower() == "true":
                cors_issues.append(
                    f"{endpoint}: Dangerous combination of ACAO:* and Credentials:true"
                )

            # Gefährlich: ACAO reflektiert beliebige Origin
            if acao == "https://evil.com":
                cors_issues.append(f"{endpoint}: CORS reflects arbitrary origin")

        except Exception:
            pass

    # ERFOLGS-KRITERIUM: Keine gefährlichen CORS-Konfigurationen
    assert len(cors_issues) == 0, (
        f"CORS misconfiguration detected! "
        f"Issues: {'; '.join(cors_issues)}"
    )
